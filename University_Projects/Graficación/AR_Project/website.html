<!DOCTYPE html>
<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>AR Project</title>
	<!-- include three.js library -->
	<script src='js/three.js'></script>
	<script src='js/OBJLoader.js'></script>
	<!-- <script src="js/lil-gui.module.min.js"></script> -->
	<!-- include jsartookit -->
	<script src="jsartoolkit5/artoolkit.min.js"></script>
	<script src="jsartoolkit5/artoolkit.api.js"></script>
	<!-- include threex.artoolkit -->
	<script src="threex/threex-artoolkitsource.js"></script>
	<script src="threex/threex-artoolkitcontext.js"></script>
	<script src="threex/threex-arbasecontrols.js"></script>
	<script src="threex/threex-armarkercontrols.js"></script>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>

<script type="module">
	function p(any){console.log(any)}
	function multiline(list){
		var max = 0
		for(const s of list){
			if(s.length > max) max = s.length
		}
		var temp = ""
		for(var s of list){
			while (s.length < max) {
				s = " " + s
			}
			temp += s + "\n"
		}
		return temp
	}
	import { GUI } from './js/lil-gui.module.min.js';
	// THREE.FontLoader()
	// THREE.TextGeometry()

	var scene, camera, renderer, clock, deltaTime, totalTime;

	var arToolkitSource, arToolkitContext;

	var markerRoot1, group1, group2;

	var cube_mesh;

	// Custom vars
	let time,t,iter=0;
	let animationRadius = 1.5;
	let spaceShipDeltaY = 0.001;

	let capybara;
	let cat;
	let skeleton;
	let skull1;
	let skull2;
	let sofa;
	let spaceship;
	let stickman;
	let varsize;

	let audio_data,audio_listener,audio_loader,audio_analyser,sound,
	songs = ["wii", "nggyu","shrek"], songIndex = 0;
	let curve, curvePoints, curveInd=0, rotationDelay = 10, currentRot = 0;
	let cube,x=0;
	let textMesh;

	initialize();
	animate();

	function initialize()
	{
		scene = new THREE.Scene();

		let ambientLight = new THREE.AmbientLight( 0xcccccc, 0.5 );
		scene.add( ambientLight );
					
		camera = new THREE.Camera();
		scene.add(camera);

		// create a font loader
		const fontLoader = new THREE.FontLoader();

		// load a font resource
		fontLoader.load('fonts/helvetiker_regular.typeface.json', function (font) {
		const nl = "\n"
		const textGeometry = new THREE.TextGeometry(multiline([
			"4a Evaluacion",
			"Proyecto final RA",
			"Modelos del Proyecto 3 llevados a un",
			"Ambiente de Realidad Aumentada",
			"por Fernando Gil"
		]), {
				font: font,
				size: .1,
				height: 0.01,
				curveSegments: 12,
				bevelEnabled: false,
				bevelThickness: 0.05,
				bevelSize: 0.05,
				bevelSegments: 5
			});
		textGeometry.center()
		const textMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff });
		textMesh = new THREE.Mesh(textGeometry, textMaterial);
		group1.add(textMesh);
		});

		renderer = new THREE.WebGLRenderer({
			antialias : true,
			alpha: true
		});
		renderer.setClearColor(new THREE.Color('lightgrey'), 0)
		renderer.setSize( 640, 480 );
		renderer.domElement.style.position = 'absolute'
		renderer.domElement.style.top = '0px'
		renderer.domElement.style.left = '0px'
		document.body.appendChild( renderer.domElement );

		clock = new THREE.Clock();
		deltaTime = 0;
		totalTime = 0;
		
		////////////////////////////////////////////////////////////
		// setup arToolkitSource
		////////////////////////////////////////////////////////////

		arToolkitSource = new THREEx.ArToolkitSource({
			sourceType : 'webcam',
		});

		function onResize()
		{
			arToolkitSource.onResize()	
			arToolkitSource.copySizeTo(renderer.domElement)	
			if ( arToolkitContext.arController !== null )
			{
				arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
			}	
		}

		arToolkitSource.init(function onReady(){
			onResize()
		});
		
		// handle resize event
		window.addEventListener('resize', function(){
			onResize()
		});
		
		////////////////////////////////////////////////////////////
		// setup arToolkitContext
		////////////////////////////////////////////////////////////	

		// create atToolkitContext
		arToolkitContext = new THREEx.ArToolkitContext({
			cameraParametersUrl: 'data/camera_para.dat',
			detectionMode: 'mono'
		});
		
		// copy projection matrix to camera when initialization complete
		arToolkitContext.init( function onCompleted(){
			camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
		});

		////////////////////////////////////////////////////////////
		// setup markerRoots
		////////////////////////////////////////////////////////////

		// build markerControls
		markerRoot1 = new THREE.Group();
		group1 = new THREE.Group();
		group2 = new THREE.Group();
		markerRoot1.add(group1)
		markerRoot1.add(group2)
		group2.visible = false
		scene.add(markerRoot1);
		let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRoot1, {
			type: 'pattern', patternUrl: "data/hiro.patt",
		})

		cube	= new THREE.BoxGeometry(1,1,1);
		let cube_mat	= new THREE.MeshNormalMaterial({
			transparent: true,
			opacity: 0.5,
			side: THREE.DoubleSide
		});
		
		// Cube
		cube_mesh = new THREE.Mesh( cube, cube_mat );
		cube_mesh.position.y = 0.5;
		group2.add( cube_mesh );

		// Curve
		curve = new THREE.CatmullRomCurve3( [
			new THREE.Vector3( .5, .5, .5 ),
			new THREE.Vector3( -.5, 0.5, .5 ),
			new THREE.Vector3( -.5, .5, -.5 ),
			new THREE.Vector3( .5, 0.5, -.5 ),
			new THREE.Vector3( .5, .5, .5 ),
		], true);
		
		curvePoints = curve.getPoints( 50 );
		const geometry = new THREE.Geometry();
		geometry.vertices = curvePoints;
		const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
		const curveObject = new THREE.Line( geometry, material );

		group2.add(curveObject)

		function onModelLoadProgress(xhr) {
		// console.log((xhr.loaded / xhr.total * 100) + '% loaded');
		}

		function onModelLoadError(error) {
		// console.log("Model error: " + error);
		}

		// instantiate a loader
		const model_loader = new THREE.OBJLoader();
		// load a resource
		model_loader.load(
			'models/objs/capybara.obj',
			function ( obj ) {
				obj.position.set(0, 1, 0)
				obj.rotation.x = Math.PI * 0.5;
				obj.rotation.y = Math.PI * 1;
				obj.rotation.z = Math.PI * 1;
				obj.scale.multiplyScalar(.05);
				group2.add(obj)
				capybara = obj;
			},onModelLoadProgress,onModelLoadError
		);

		model_loader.load(
			'models/objs/cat.obj',
			function ( obj ) {
				obj.position.set(0, .5, 0)
				obj.rotation.x = Math.PI * 0.5;
				obj.rotation.y = Math.PI * 1;
				obj.rotation.z = Math.PI * 1;
				obj.scale.multiplyScalar(.01);
				group2.add(obj)
				cat = obj;
			},onModelLoadProgress,onModelLoadError
		);

		model_loader.load(
			'models/objs/skull.obj',
			function ( obj ) {
				obj.position.set(0, .5, 0)
				obj.scale.multiplyScalar(0.025);
				group2.add(obj)
				skull1 = obj;
			},onModelLoadProgress,onModelLoadError
		);

		model_loader.load(
			'models/objs/skeleton.obj',
			function ( obj ) {
				obj.position.set(-.25, .45, 0.05)
				obj.scale.multiplyScalar(.01);
				group2.add(obj)
				skeleton = obj;
			},onModelLoadProgress,onModelLoadError
		);

		model_loader.load(
			'models/objs/sofa.obj',
			function ( obj ) {
				obj.position.set(0, 0.1, -.25)
				obj.scale.multiplyScalar(.5);
				group2.add(obj)
				sofa = obj;
			},onModelLoadProgress,onModelLoadError
		);

		model_loader.load(
			'models/objs/spaceship.obj',
			function ( obj ) {
				obj.position.set(2, .5, -2)
				obj.scale.multiplyScalar(.4);
				obj.rotation.y = -Math.PI * 0.2;
				group2.add(obj)
				spaceship = obj;
			},onModelLoadProgress,onModelLoadError
		);

		model_loader.load(
			'models/objs/stickman.obj',
			function ( obj ) {
				obj.position.set(0, .3, 0.05)
				group2.add(obj)
				obj.scale.multiplyScalar(.0075);
				stickman = obj;
			},onModelLoadProgress,onModelLoadError
		);	

		// Music
		audio_listener = new THREE.AudioListener();
		camera.add( audio_listener );
		sound = new THREE.Audio( audio_listener );
		audio_analyser = new THREE.AudioAnalyser( sound, 32 );
		audio_loader = new THREE.AudioLoader();
		audio_loader.load( 'audio/'+songs[0]+'.mp3', function( buffer ) {
			sound.setBuffer( buffer );
			sound.setLoop(true);
			sound.setVolume(0.5);
		});
		// Funciones para el GUI que muestran a cada planeta.
		const params = {
			Credits: function () {
				group1.visible = !group1.visible
				group2.visible = !group2.visible
			},
			PlayPause: function () {
				if(sound.isPlaying)	sound.pause();
				else sound.play();
			},
			ChangeSong: function () {
				songIndex = songIndex + 1 > songs.length-1 ? 0 : songIndex+1;
				sound.stop()
				audio_loader.load('audio/'+songs[songIndex]+'.mp3', function( buffer ) {
					sound.setBuffer( buffer );
					sound.setLoop(true);
					sound.setVolume(0.5);
					sound.play();
				});
			},
			openReport: function () {
				window.open("report.pdf", '_blank');
			},
		};
		const gui = new GUI();
		gui.add( params, 'Credits' ).name( 'Mostrar/Quitar texto' );
		gui.add( params, 'PlayPause' ).name( 'Iniciar/Detener música' );
		gui.add( params, 'ChangeSong' ).name( 'Cambiar canción' );
		gui.add( params, 'openReport' ).name( 'Abrir reporte' );
		gui.open();


	}


	function update()
	{
		time = .00025* performance.now();
		t = time % 1;
		varsize = Math.abs(Math.cos(time*10/2) * 150)
		if(group2.visible){
			if(cat){
				cat.position.x = -Math.cos(time*10/2) * animationRadius;
				cat.position.z = Math.sin(time*10/2) * animationRadius;
				cat.rotation.y = Math.PI * (time*1.5);
				cat.rotation.z = Math.PI * (time*2);
				cat.rotation.x = Math.PI * (time*3);
				cat.scale.multiplyScalar((Math.cos(time*10)>0 ? 1.01 : 0.99))
			}
			if(capybara){
				capybara.position.y = -Math.cos(time*10/2+20) * animationRadius;
				capybara.position.z = Math.sin(time*10/2+20) * animationRadius;
				capybara.rotation.y = Math.PI * (time*1.5);
				capybara.rotation.z = Math.PI * (time*2);
				capybara.rotation.x = Math.PI * (time*3);
				capybara.scale.multiplyScalar((-Math.cos(time*10)>0 ? 1.01 : 0.99))
			}
			if(skull1 && audio_analyser){
				if(curveInd > curvePoints.length-1)  curveInd = 0
				const freq = audio_analyser.getAverageFrequency()
				const pointOnCurve = curvePoints[curveInd];
				skull1.position.x = pointOnCurve.x
				skull1.position.z = pointOnCurve.z
				const setscale = freq ? freq/1000 : 0.025;
				skull1.scale.set(setscale,setscale,setscale)
				skull1.position.y = pointOnCurve.y + freq/200;
				currentRot +=1
				if(currentRot == rotationDelay) {
					currentRot = 0
					curveInd += 1
				}
				skull1.rotation.y = Math.PI * (time*1.5);

			}
			if(spaceship){
				spaceship.position.y = (Math.cos(time*10)>0 ? 
				spaceship.position.y + spaceShipDeltaY : spaceship.position.y-spaceShipDeltaY)
				spaceship.rotation.x = -Math.PI * (Math.cos(time*10)*.01);
			}
		}
		if(group1.visible){
			if(textMesh){
				textMesh.position.y = Math.cos(time*10/2) * 0.2;
				textMesh.rotation.y = Math.cos(time*10/4) * 0.2;
			}
		}
		iter++
		// update artoolkit on every frame
		if ( arToolkitSource.ready !== false )
			arToolkitContext.update( arToolkitSource.domElement );
	}


	function render()
	{
		renderer.render( scene, camera );
	}


	function animate()
	{
		requestAnimationFrame(animate);
		deltaTime = clock.getDelta();
		totalTime += deltaTime;
		update();
		render();
	}

</script>

</body>
</html>